  # -*- coding: utf-8 -*-
"""
Module for handling various utility functions and executing code for testing purposes.

This module provides functions for running C/C++ code snippets for testing purposes.
It includes functions for executing code, handling file paths, and interacting with subprocesses.

Functions
---------
    - callCPP(): Executes C++ code.
    - callC(): Executes C code.
    - callCPPFunction(): Executes C++ code along with a specific function.
    - callCFunction(): Executes C code along with a specific function.
"""

import subprocess
import os


def callCPP(cmdline_args:list[str] = [], input:str='', timeout:int=30, compiler:str='g++', enable_VS:bool=True) -> str:
    """Execute a C++ program and return the output.

    This function compiles and executes a C++ program located in the `src` directory of the current project. 
    It delegates the compilation and execution to the `callC` function, passing the appropriate parameters for a C++ program.

    Parameters
    ----------
    cmdline_args : list[str], optional
        Additional command-line arguments to pass to the program, by default []
    input : str, optional
        Input to be passed to the program, by default ''
    timeout : int, optional
        Maximum time in seconds to wait for the program to execute, by default 30
    compiler : str, optional
        Compiler to use for compilation, by default 'g++'
    enable_VS : bool, optional
        Flag indicating whether to enable Visual Studio compiler, by default True

    Returns
    -------
    str
        Standard output generated by the executed program.

    Notes
    -------
    This function relies on the `callC` function to handle the compilation and execution process. It passes the appropriate parameters for compiling a C++ program.
    - If Visual Studio compiler is enabled (`enable_VS=True`), the function attempts to compile the source code using `cl.exe`.
    - If compilation fails or Visual Studio compiler is not enabled, the function falls back to the specified compiler (g++ by default) to compile the source code.
    """
    return callC(cmdline_args, input, timeout, compiler, 'my_code.cpp', enable_VS)

def callC(cmdline_args:list[str]=[], input:str='', timeout:int=30, compiler:str='gcc', source:str='my_code.c', enable_VS:bool=True):
    """Execute a C program and return the output.

    This function compiles and executes a C program located in the `src` directory of the current project. 
    It delegates the compilation and execution to the appropriate compiler (GCC by default) or the Visual Studio compiler if enabled.

    Parameters
    ----------
    cmdline_args : list[str], optional
        Additional command-line arguments to pass to the program, by default []
    input : str, optional
        Input to be passed to the program, by default ''
    timeout : int, optional
        Maximum time in seconds to wait for the program to execute, by default 30
    compiler : str, optional
        Compiler to use for compilation, by default 'gcc'
    source : str, optional
        Name of the C source file, by default 'my_code.c'
    enable_VS : bool, optional
        Flag indicating whether to enable Visual Studio compiler, by default True

    Returns
    -------
    str
        Standard output generated by the executed program.

    Raises
    ------
    FileNotFoundError
        If the compilation fails, indicated by a non-zero return code from the compiler.
    FileNotFoundError
        If the compilation fails, indicated by a non-zero return code from the compiler.
    FileNotFoundError
        If the compilation fails, indicated by a non-zero return code from the compiler.

    Notes
    -------
        - If Visual Studio compiler is enabled (`enable_VS=True`), the function attempts to compile the source code using `cl.exe`.
        - If compilation fails or Visual Studio compiler is not enabled, the function falls back to the specified compiler (GCC by default) to compile the source code.
        - The compiled program is executed, and its standard output is returned.

    """
    path=os.getcwd()

    #Compile the source code
    VS_compile_succeed=False
    if enable_VS:
        try:
            rc = subprocess.run(['cl.exe', source], cwd=path+'/src', shell=True)
            if rc.returncode!=0:
                raise FileNotFoundError
            VS_compile_succeed=True
        except:
            print('Visual Studio compile failed, trying GCC!')
    
    if not VS_compile_succeed:
        try:
            rc = subprocess.run([compiler,source,'-o','my_code.exe'], cwd=path+'/src', shell=True)
            if rc.returncode!=0:
                raise FileNotFoundError
        except:
            print('!!Compile dropped to fallback!!')
            rc = subprocess.run([compiler+' '+source+' -o my_code.exe'], cwd=path+'/src', shell=True)
            print("Fallback completed, don't worry")


    try:
        cmd_line=['./my_code.exe']+cmdline_args
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
        if rc.returncode!=0:
            raise FileNotFoundError
    except:
        print('!!Running dropped to fallback!!')
        cmd_line=[path+'\\src\\my_code.exe']+cmdline_args
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
        print("Fallback completed, don't worry")

    return rc.stdout

def callCPPFunction(cmdline_args:list[str]=[], input:str='', timeout:int=30, compiler:str='g++', source:str='my_code.cpp', testmain:str='../tests/testmain.cpp', enable_VS:bool=True) -> str:
    """Execute a C++ program and return the output.

    This function compiles and executes a C++ program located in the `src` directory of the current project. 
    It delegates the compilation and execution to the appropriate compiler (g++ by default) or the Visual Studio compiler if enabled.

    Parameters
    ----------
    cmdline_args : list[str], optional
        Additional command-line arguments to pass to the program, by default []
    input : str, optional
       Input to be passed to the program, by default ''
    timeout : int, optional
        Maximum time in seconds to wait for the program to execute, by default 30
    compiler : str, optional
        Compiler to use for compilation, by default 'g++'
    source : str, optional
        Name of the C++ source file, by default 'my_code.cpp'
    testmain : str, optional
        Path to the test main file used for compilation, by default '../tests/testmain.cpp'
    enable_VS : bool, optional
        Flag indicating whether to enable Visual Studio compiler, by default True

    Returns
    -------
    str
        Standard output generated by the executed program.

    Notes
    -------
        - If Visual Studio compiler is enabled (`enable_VS=True`), the function attempts to compile the source code using `cl.exe`.
        - If compilation fails or Visual Studio compiler is not enabled, the function falls back to the specified compiler (g++ by default) to compile the source code.
        - The compiled program is executed, and its standard output is returned.
    """
    return callCFunction(cmdline_args, input, timeout, compiler, source, testmain, enable_VS)


def callCFunction(cmdline_args:list[str]=[], input:str='', timeout:int=30, compiler:str='gcc', source:str='my_code.c', testmain:str='../tests/testmain.c', enable_VS:bool=True) -> str:
    """ Execute a C program and return the output.

    This function compiles and executes a C program located in the `src` directory of the current project. 
    It delegates the compilation and execution to the appropriate compiler (gcc by default) or the Visual Studio compiler if enabled.

    Parameters
    ----------
    cmdline_args : list[str], optional
        Additional command-line arguments to pass to the program, by default []
    input : str, optional
        Input to be passed to the program, by default ''
    timeout : int, optional
        Maximum time in seconds to wait for the program to execute, by default 30
    compiler : str, optional
        Compiler to use for compilation, by default 'gcc'
    source : str, optional
         Name of the C source file, by default 'my_code.c'
    testmain : str, optional
        Path to the test main file used for compilation, by default '../tests/testmain.c'
    enable_VS : bool, optional
        Flag indicating whether to enable Visual Studio compiler, by default True

    Returns
    -------
    str
        Standard output generated by the executed program.

    Raises
    ------
    FileNotFoundError
        If the compilation fails, indicated by a non-zero return code from the compiler.
    FileNotFoundError
        If the compilation fails, indicated by a non-zero return code from the compiler.
    FileNotFoundError
        If the compilation fails, indicated by a non-zero return code from the compiler.

    Notes
    -------
        - If Visual Studio compiler is enabled (`enable_VS=True`), the function attempts to compile the source code using `cl.exe`.
        - If compilation fails or Visual Studio compiler is not enabled, the function falls back to the specified compiler (gcc by default) to compile the source code.
        - The compiled program is executed, and its standard output is returned.
    """
    path=os.getcwd()

    #Compile the source code
    VS_compile_succeed=False
    if enable_VS:
        try:
            rc = subprocess.run(['cl.exe', source, testmain, '/DCLIBRARYTEST'], cwd=path+'/src', shell=True)
            if rc.returncode!=0:
                raise FileNotFoundError
            VS_compile_succeed=True
        except:
            print('Visual Studio compile failed, trying GCC!')
    
    if not VS_compile_succeed:
        try:
            rc = subprocess.run([compiler, source, testmain, '-o', 'my_code.exe', '-D', 'CLIBRARYTEST'], cwd=path+'/src', shell=True)
            if rc.returncode!=0:
                raise FileNotFoundError
        except:
            print('!!Compile dropped to fallback!!')
            rc = subprocess.run([compiler+' '+source+' '+testmain+' -o my_code.exe -DCLIBRARYTEST'], cwd=path+'/src', shell=True)
            print("Fallback completed, don't worry")


    try:
        cmd_line=['./my_code.exe']+cmdline_args
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
        if rc.returncode!=0:
            raise FileNotFoundError
    except:
        print('!!Running dropped to fallback!!')
        cmd_line=[path+'\\src\\my_code.exe']+cmdline_args
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
        print("Fallback completed, don't worry")

    return rc.stdout