  # -*- coding: utf-8 -*-
"""
Module for handling various utility functions and executing code for testing purposes.

This module provides functions for running C/C++ code snippets for testing purposes.
It includes functions for executing code, handling file paths, running tests, and interacting with subprocesses.

Functions:
    - callCPP(): Executes C++ code.
    - callC(): Executes C code.
    - callCPPFunction(): Executes C++ code along with a specific function.
    - callCFunction(): Executes C code along with a specific function.
"""

import subprocess
import os


def callCPP(cmdline_args=[], input='', timeout=30, compiler='g++', enable_VS=True):
    """
    Execute a C++ program and return the output.

    This function compiles and executes a C++ program located in the `src` directory of the current project. It delegates the compilation and execution to the `callC` function, passing the appropriate parameters for a C++ program.

    Args:
        cmdline_args (list, optional): Additional command-line arguments to pass to the program. Defaults to [].
        input (str, optional): Input to be passed to the program. Defaults to ''.
        timeout (int, optional): Maximum time in seconds to wait for the program to execute. Defaults to 30.
        compiler (str, optional): Compiler to use for compilation. Defaults to 'g++'.
        enable_VS (bool, optional): Flag indicating whether to enable Visual Studio compiler. Defaults to True.

    Returns:
        str: Standard output generated by the executed program.

    Notes:
        This function relies on the `callC` function to handle the compilation and execution process. It passes the appropriate parameters for compiling a C++ program.

    """
    return callC(cmdline_args, input, timeout, compiler, 'my_code.cpp', enable_VS)

def callC(cmdline_args=[], input='', timeout=30, compiler='gcc', source='my_code.c', enable_VS=True):
    """
    Execute a C program and return the output.

    This function compiles and executes a C program located in the `src` directory of the current project. It delegates the compilation and execution to the appropriate compiler (GCC by default) or the Visual Studio compiler if enabled.

    Args:
        cmdline_args (list, optional): Additional command-line arguments to pass to the program. Defaults to [].
        input (str, optional): Input to be passed to the program. Defaults to ''.
        timeout (int, optional): Maximum time in seconds to wait for the program to execute. Defaults to 30.
        compiler (str, optional): Compiler to use for compilation. Defaults to 'gcc'.
        source (str, optional): Name of the C source file. Defaults to 'my_code.c'.
        enable_VS (bool, optional): Flag indicating whether to enable Visual Studio compiler. Defaults to True.

    Returns:
        str: Standard output generated by the executed program.

    Notes:
        - If Visual Studio compiler is enabled (`enable_VS=True`), the function attempts to compile the source code using `cl.exe`.
        - If compilation fails or Visual Studio compiler is not enabled, the function falls back to the specified compiler (GCC by default) to compile the source code.
        - The compiled program is executed, and its standard output is returned.
    """
    path=os.getcwd()

    #Compile the source code
    VS_compile_succeed=False
    if enable_VS:
        try:
            rc = subprocess.run(['cl.exe', source], cwd=path+'/src', shell=True)
            if rc.returncode!=0:
                raise FileNotFoundError
            VS_compile_succeed=True
        except:
            print('Visual Studio compile failed, trying GCC!')
    
    if not VS_compile_succeed:
        try:
            rc = subprocess.run([compiler,source,'-o','my_code.exe'], cwd=path+'/src', shell=True)
            if rc.returncode!=0:
                raise FileNotFoundError
        except:
            print('!!Compile dropped to fallback!!')
            rc = subprocess.run([compiler+' '+source+' -o my_code.exe'], cwd=path+'/src', shell=True)
            print("Fallback completed, don't worry")


    try:
        cmd_line=['./my_code.exe']+cmdline_args
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
        if rc.returncode!=0:
            raise FileNotFoundError
    except:
        print('!!Running dropped to fallback!!')
        cmd_line=[path+'\\src\\my_code.exe']+cmdline_args
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
        print("Fallback completed, don't worry")

    return rc.stdout

def callCPPFunction(cmdline_args=[], input='', timeout=30, compiler='g++', source='my_code.cpp', testmain='../tests/testmain.cpp', enable_VS=True):
    """
    Execute a C++ program and return the output.

    This function compiles and executes a C++ program located in the `src` directory of the current project. It delegates the compilation and execution to the appropriate compiler (g++ by default) or the Visual Studio compiler if enabled.

    Args:
        cmdline_args (list, optional): Additional command-line arguments to pass to the program. Defaults to [].
        input (str, optional): Input to be passed to the program. Defaults to ''.
        timeout (int, optional): Maximum time in seconds to wait for the program to execute. Defaults to 30.
        compiler (str, optional): Compiler to use for compilation. Defaults to 'g++'.
        source (str, optional): Name of the C++ source file. Defaults to 'my_code.cpp'.
        testmain (str, optional): Path to the test main file used for compilation. Defaults to '../tests/testmain.cpp'.
        enable_VS (bool, optional): Flag indicating whether to enable Visual Studio compiler. Defaults to True.

    Returns:
        str: Standard output generated by the executed program.

    Notes:
        - If Visual Studio compiler is enabled (`enable_VS=True`), the function attempts to compile the source code using `cl.exe`.
        - If compilation fails or Visual Studio compiler is not enabled, the function falls back to the specified compiler (g++ by default) to compile the source code.
        - The compiled program is executed, and its standard output is returned.
    """
    return callCFunction(cmdline_args, input, timeout, compiler, source, testmain, enable_VS)


def callCFunction(cmdline_args=[], input='', timeout=30, compiler='gcc', source='my_code.c', testmain='../tests/testmain.c', enable_VS=True):
    """
    Execute a C program and return the output.

    This function compiles and executes a C program located in the `src` directory of the current project. It delegates the compilation and execution to the appropriate compiler (gcc by default) or the Visual Studio compiler if enabled.

    Args:
        cmdline_args (list, optional): Additional command-line arguments to pass to the program. Defaults to [].
        input (str, optional): Input to be passed to the program. Defaults to ''.
        timeout (int, optional): Maximum time in seconds to wait for the program to execute. Defaults to 30.
        compiler (str, optional): Compiler to use for compilation. Defaults to 'gcc'.
        source (str, optional): Name of the C source file. Defaults to 'my_code.c'.
        testmain (str, optional): Path to the test main file used for compilation. Defaults to '../tests/testmain.c'.
        enable_VS (bool, optional): Flag indicating whether to enable Visual Studio compiler. Defaults to True.

    Returns:
        str: Standard output generated by the executed program.

    Notes:
        - If Visual Studio compiler is enabled (`enable_VS=True`), the function attempts to compile the source code using `cl.exe`.
        - If compilation fails or Visual Studio compiler is not enabled, the function falls back to the specified compiler (gcc by default) to compile the source code.
        - The compiled program is executed, and its standard output is returned.
    """
    path=os.getcwd()

    #Compile the source code
    VS_compile_succeed=False
    if enable_VS:
        try:
            rc = subprocess.run(['cl.exe', source, testmain, '/DCLIBRARYTEST'], cwd=path+'/src', shell=True)
            if rc.returncode!=0:
                raise FileNotFoundError
            VS_compile_succeed=True
        except:
            print('Visual Studio compile failed, trying GCC!')
    
    if not VS_compile_succeed:
        try:
            rc = subprocess.run([compiler, source, testmain, '-o', 'my_code.exe', '-D', 'CLIBRARYTEST'], cwd=path+'/src', shell=True)
            if rc.returncode!=0:
                raise FileNotFoundError
        except:
            print('!!Compile dropped to fallback!!')
            rc = subprocess.run([compiler+' '+source+' '+testmain+' -o my_code.exe -DCLIBRARYTEST'], cwd=path+'/src', shell=True)
            print("Fallback completed, don't worry")


    try:
        cmd_line=['./my_code.exe']+cmdline_args
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
        if rc.returncode!=0:
            raise FileNotFoundError
    except:
        print('!!Running dropped to fallback!!')
        cmd_line=[path+'\\src\\my_code.exe']+cmdline_args
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
        print("Fallback completed, don't worry")

    return rc.stdout