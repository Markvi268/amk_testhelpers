   # -*- coding: utf-8 -*-
"""
Module for handling various utility functions and executing code for testing purposes.

This module provides functions for running Python, C/C++, and .NET code snippets for testing purposes.
It includes functions for executing code, handling file paths, running tests, and interacting with subprocesses.

Functions:
    - getpath(): Returns the path to the current root directory.
    - callpythoncode(): Executes Python code snippets.
    - callpythonmaincode(): Executes Python code snippets along with the main code.
    - loadmycode(): Loads the student's Python code.
    - callpython(): Executes the main Python code.
    - callpython_subprocess(): Runs the main Python code in a separate thread.
    - load_python_code(): Loads the Python code from the source file.
    - dotNetProjectName(): Retrieves the name of the .NET project.
    - dotNetNumbersFormat(): Retrieves the decimal and separator format for .NET.
    - callDotNet(): Executes .NET code.
    - callDotNetFunction(): Executes .NET code along with a specific function.
    - callMono(): Executes Mono code.
    - callMonoFunction(): Executes Mono code along with a specific function.
    - callCPP(): Executes C++ code.
    - callC(): Executes C code.
    - callCPPFunction(): Executes C++ code along with a specific function.
    - callCFunction(): Executes C code along with a specific function.
    - split(): Splits a string using forward and backward slashes.
    - runTest(): Runs unit tests for the specified module.
"""
import sys
import subprocess
import re
import os
import shutil
import glob
import threading
import unittest



def getpath():
    """
    Returns the path to the current root.

    If the program is executed from the command line, this function returns 
    the path corresponding to the execution directory of the program. If the 
    program is not executed from the command line, the path to the current 
    directory is returned.

    Returns:
        str: Path to the current root.
    """
    pathlist = split(sys.argv[0])
    if len(pathlist) == 1:
        path = './'
    else:
        path = pathlist[0] + '/'
    return path

def callpythoncode(code, cmdline_args=[], input='', timeout=30):
    """
    Execute the provided Python code in a separate process.

    Args:
        code (str): Python code to execute.
        cmdline_args (list, optional): Command-line arguments to pass to the executed code (default []). 
        input (str, optional): Input to provide to the executed code (default '').
        timeout (int, optional): Maximum time (in seconds) to allow the execution before timing out (default 30).

    Returns:
        str: Standard output generated by the executed code.

    Raises:
        TimeoutExpired: If the execution exceeds the specified timeout.

    Note:
        The provided Python code is executed in a separate process. 
        Any standard output generated by the executed code is returned as a string.
        If the execution times out, a TimeoutExpired exception is raised.

    """
    path = os.getcwd()

    testcodefile='tests/my_test_code.py'
    f=open(testcodefile, "w")
    f.write(code)
    f.close()
    
    cmd_line=[sys.executable, '../'+testcodefile,]+cmdline_args
    try:
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
    except subprocess.TimeoutExpired:
        print('Timeout expired!')
        return ''
    except:
        print('Execute dropped to fallback!')
        cmd_line_str=' '.join(cmd_line)
        rc = subprocess.run(cmd_line_str, cwd=path+'/src', stdout=subprocess.PIPE, universal_newlines=True, input=input, timeout=timeout)
        print("Fallback completed, don't worry")

    os.remove(testcodefile)    
    
    return rc.stdout

#Run my_code.py and additional code
def callpythonmaincode(code, cmdline_args=[], input='', timeout=30):
    """
        Execute the provided Python code along with the main code in a separate process.

        This function first loads the main Python code from the file specified by 'loadmycode()',
        then combines it with the provided 'code' parameter, and finally executes the combined
        code in a separate process.

        Args:
        code (str): Additional Python code to execute along with the main code.
        cmdline_args (list, optional): Command-line arguments to pass to the executed code (default []). 
        input (str, optional): Input to provide to the executed code (default '').
        timeout (int, optional): Maximum time (in seconds) to allow the execution before timing out (default 30).

        Returns:
            str: Standard output generated by the executed code.

        Raises:
            TimeoutExpired: If the execution exceeds the specified timeout.

        Note:
            The provided 'code' parameter is combined with the main Python code obtained
            using the 'loadmycode()' function. The combined code is then executed in a 
            separate process. Any standard output generated by the executed code is 
            returned as a string. If the execution times out, a TimeoutExpired exception 
            is raised.

    """
    my_code=loadmycode()

    return callpythoncode(code=my_code+code, cmdline_args=cmdline_args, input=input, timeout=timeout)

#Load student code
def loadmycode(codefile='src/my_code.py'):
    """
    Load the Python code from the specified file.

    This function attempts to read the Python code from the file specified by the 'codefile'
    parameter. It tries different encodings ('latin1', 'utf8', 'utf16', 'cp437') to decode
    the file content until successful or until all encodings have been attempted.

    Args:
        codefile (str, optional): Path to the Python code file to load (default 'src/my_code.py').

    Returns:
        str: Loaded Python code as a string.

    """
    for encoding in ['latin1', 'utf8','utf16','cp437']:
        try:
            with open(codefile, encoding=encoding) as f:
                my_code = f.read()
            return my_code
        except:
            pass

#Run my_code.py
def callpython(cmdline_args=[], input='', timeout=30):
    """
    Run a Python script with optional command-line arguments, input, and timeout.

    This function executes a Python script specified by the 'my_code.py' file in the 'src' directory.
    It allows passing optional command-line arguments and input to the script, and sets a timeout
    for the execution.

    Args:
        cmdline_args (list, optional): List of command-line arguments to pass to the Python script (default []).
        input (str, optional): Input string to provide to the Python script (default '').
        timeout (int, optional): Timeout value in seconds for the script execution (default 30).

    Returns:
        str: Output generated by the Python script.

    Raises:
        subprocess.TimeoutExpired: If the execution of the Python script exceeds the specified timeout.
        FileNotFoundError: If the Python interpreter is not found or if the 'my_code.py' file does not exist.

    Note:
        This function executes the Python script using the 'subprocess' module. It captures the standard output
        of the script and returns it as a string. If the execution exceeds the specified timeout, a 
        subprocess.TimeoutExpired exception is raised.

    """
    path = os.getcwd()

    cmd_line=[sys.executable, 'my_code.py',]+cmdline_args
    try:
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
    except subprocess.TimeoutExpired:
        print('Timeout expired!')
        return ''
    except:
        print('Execute dropped to fallback!')
        cmd_line_str=' '.join(cmd_line)
        print('"',cmd_line_str, '"')
        rc = subprocess.run(cmd_line_str, cwd=path+'/src', stdout=subprocess.PIPE, universal_newlines=True, input=input, timeout=timeout)
        print("Fallback completed, don't worry")

    return rc.stdout



#Run my_code.py in separate thread
def callpython_subprocess(cmdline_args=[], input='', timeout=30):
    """
    Run a Python script in a separate thread with optional command-line arguments, input, and timeout.

    This function creates a new thread to execute a Python script specified by the 'my_code.py' file 
    in the 'src' directory. It allows passing optional command-line arguments and input to the script, 
    and sets a timeout for the execution.

    Args:
        cmdline_args (list, optional): List of command-line arguments to pass to the Python script (default []).
        input (str, optional): Input string to provide to the Python script (default '').
        timeout (int, optional): Timeout value in seconds for the script execution (default 30).

    Returns:
        threading.Thread: A Thread object representing the newly created thread.

    Note:
        This function creates a new thread using the 'threading' module to execute the Python script 
        asynchronously. It does not wait for the script to complete and returns the Thread object 
        immediately. The execution of the script happens concurrently in the background. Use the 
        'join' method of the returned Thread object to wait for the script execution to finish if needed.
        Any exceptions that occur during the script execution will not be raised immediately in the 
        main thread but can be handled by checking the status of the Thread object.

    """
    th=threading.Thread(target=callpython, args=(cmdline_args, input, timeout))
    th.start()
    return th

def load_python_code():
    """
    Load the contents of the Python script 'my_code.py' located in the 'src' directory.

    This function reads the contents of the Python script 'my_code.py' and returns it as a string.

    Returns:
        str: Contents of the Python script 'my_code.py'.
    """
    file_name=getpath()+'/src/my_code.py'
    with open(file_name) as f:
        contents = f.read()
        return contents
    
def dotNetProjectName():
    """
    Get the name of the .NET project.

    This function searches for .csproj files in the current directory and returns the name of the first project found without the extension.

    Returns:
        str: Name of the .NET project without the extension.

    """
    project_files=glob.glob('*.csproj')
    project_file=project_files[0]
    return os.path.splitext(project_file)[0]


def dotNetNumbersFormat():
    """
    Get the numeric format settings used by the system.

    This function uses the `locale` module to retrieve the numeric format settings 
    (such as the negative sign and decimal point) from the system. 
    It sets the locale to the default system locale and then retrieves the numeric formatting information. 
    If the system does not provide a negative sign, it defaults to '-'.

    Returns:
        Tuple[str, str]: A tuple containing the negative sign and the decimal point used by the system.

    Notes:
        This function relies on the `locale` module, which may not be available or may behave differently across different systems.

    Warning:
        The behavior of this function may vary depending on the operating system and system configuration.

    See Also:
        https://docs.python.org/3/library/locale.html

    """
    import locale

    locale.setlocale(locale.LC_ALL, '')
    locale_info = locale.localeconv()

    neg = locale_info['negative_sign'] if locale_info['negative_sign'] else '-'
    sep = locale_info['decimal_point']
   
    return neg, sep


def callDotNet(cmdline_args=[], input='', timeout=30, build=True):
    """
    Execute a .NET program and return the output.

    This function compiles and executes a .NET program located in the `src` directory of the current project. 
    It first cleans up any temporary directories created during previous builds if the `build` parameter is set to True. 
    Then, it compiles the source code using the `dotnet build` command. 
    If the compilation fails, it falls back to a second attempt to compile using the same command. 
    Finally, it executes the compiled program and returns the standard output.

    Args:
        cmdline_args (list, optional): Additional command-line arguments to pass to the program. Defaults to [].
        input (str, optional): Input to be passed to the program. Defaults to ''.
        timeout (int, optional): Maximum time in seconds to wait for the program to execute. Defaults to 30.
        build (bool, optional): Flag indicating whether to perform a build before execution. Defaults to True.

    Returns:
        str: Standard output generated by the executed program.

    Raises:
        FileNotFoundError: If there is an error during compilation.

    Notes:
        This function relies on the `subprocess` module to execute shell commands and may not work as expected on all systems.

    Warning:
        The behavior of this function may vary depending on the environment and system configuration.

    """
    path=os.getcwd()
    project_name=dotNetProjectName()

    tmp_directories=['bin', 'obj']
    if build:
        for d in tmp_directories:
            try:
                shutil.rmtree(d)
            except:
                pass
    
    #Compile the source code
    #shutil.copy2('tests/my_code.csproj', 'src/my_code.csproj')
    if build:
        try:
            rc = subprocess.run(['dotnet', 'build'], cwd=path, shell=True)
            if rc.returncode!=0:
                raise FileNotFoundError
        except:
            print('!!Compile falled to fallback!!')
            rc = subprocess.run(['dotnet build'], cwd=path, shell=True)
            print("Fallback completed, don't worry")

    try:
        cmd_line=['bin/Debug/net6.0/'+project_name+'.exe',]+cmdline_args
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
    except:
        print('!!Running falled to fallback!!')
        cmd_line=['../bin/Debug/net6.0/'+project_name,]+cmdline_args
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
        print("Fallback completed, don't worry")

    return rc.stdout

def callDotNetFunction(cmdline_args=[], input='', timeout=30, build=True):
    """
    Execute a .NET program and return the output.

    This function compiles and executes a .NET program located in the `src` directory of the current project. It first cleans up any temporary directories created during previous builds if the `build` parameter is set to True. Then, it compiles the source code using the `dotnet build` command. If the compilation fails, it falls back to a second attempt to compile using the same command. Finally, it executes the compiled program and returns the standard output.

    Args:
        cmdline_args (list, optional): Additional command-line arguments to pass to the program. Defaults to [].
        input (str, optional): Input to be passed to the program. Defaults to ''.
        timeout (int, optional): Maximum time in seconds to wait for the program to execute. Defaults to 30.
        build (bool, optional): Flag indicating whether to perform a build before execution. Defaults to True.

    Returns:
        str: Standard output generated by the executed program.

    Raises:
        FileNotFoundError: If there is an error during compilation.

    Notes:
        This function relies on the `subprocess` module to execute shell commands and may not work as expected on all systems.

    Warning:
        The behavior of this function may vary depending on the environment and system configuration.

    """
    path=getpath()
    project_name=dotNetProjectName()

    tmp_directories=['bin', 'obj']
    if build:
        for d in tmp_directories:
            try:
                shutil.rmtree(d)
            except:
                pass

    #shutil.copy2('tests/testmain.cs', 'src/testmain.cs')
    #shutil.copy2('tests/my_code.csproj', 'src/my_code.csproj')
    #Compile the source code
    if build:
        if os.path.exists('tests/testmain.cs.hidden'):
            shutil.copyfile('tests/testmain.cs.hidden', 'tests/testmain.cs')
        try:
            rc = subprocess.run(['dotnet', 'build'], cwd=path, shell=True)
            if rc.returncode!=0:
                raise FileNotFoundError
        except:
            print('!!Compile falled to fallback!!')
            rc = subprocess.run(['dotnet build'], cwd=path, shell=True)
            print("Fallback completed, don't worry")
        finally:
            if os.path.exists('tests/testmain.cs.hidden'):
                os.remove('tests/testmain.cs')


    try:
        cmd_line=['bin/Debug/net6.0/'+project_name+'.exe',]+cmdline_args
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
    except:
        print('!!Running falled to fallback!!')
        cmd_line=['../bin/Debug/net6.0/'+project_name,]+cmdline_args
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
        print("Fallback completed, don't worry")

    return rc.stdout


def callCPP(cmdline_args=[], input='', timeout=30, compiler='g++', enable_VS=True):
    """
    Execute a C++ program and return the output.

    This function compiles and executes a C++ program located in the `src` directory of the current project. It delegates the compilation and execution to the `callC` function, passing the appropriate parameters for a C++ program.

    Args:
        cmdline_args (list, optional): Additional command-line arguments to pass to the program. Defaults to [].
        input (str, optional): Input to be passed to the program. Defaults to ''.
        timeout (int, optional): Maximum time in seconds to wait for the program to execute. Defaults to 30.
        compiler (str, optional): Compiler to use for compilation. Defaults to 'g++'.
        enable_VS (bool, optional): Flag indicating whether to enable Visual Studio compiler. Defaults to True.

    Returns:
        str: Standard output generated by the executed program.

    Notes:
        This function relies on the `callC` function to handle the compilation and execution process. It passes the appropriate parameters for compiling a C++ program.

    """
    return callC(cmdline_args, input, timeout, compiler, 'my_code.cpp', enable_VS)

def callC(cmdline_args=[], input='', timeout=30, compiler='gcc', source='my_code.c', enable_VS=True):
    """
    Execute a C program and return the output.

    This function compiles and executes a C program located in the `src` directory of the current project. It delegates the compilation and execution to the appropriate compiler (GCC by default) or the Visual Studio compiler if enabled.

    Args:
        cmdline_args (list, optional): Additional command-line arguments to pass to the program. Defaults to [].
        input (str, optional): Input to be passed to the program. Defaults to ''.
        timeout (int, optional): Maximum time in seconds to wait for the program to execute. Defaults to 30.
        compiler (str, optional): Compiler to use for compilation. Defaults to 'gcc'.
        source (str, optional): Name of the C source file. Defaults to 'my_code.c'.
        enable_VS (bool, optional): Flag indicating whether to enable Visual Studio compiler. Defaults to True.

    Returns:
        str: Standard output generated by the executed program.

    Notes:
        - If Visual Studio compiler is enabled (`enable_VS=True`), the function attempts to compile the source code using `cl.exe`.
        - If compilation fails or Visual Studio compiler is not enabled, the function falls back to the specified compiler (GCC by default) to compile the source code.
        - The compiled program is executed, and its standard output is returned.
    """
    path=getpath()

    #Compile the source code
    VS_compile_succeed=False
    if enable_VS:
        try:
            rc = subprocess.run(['cl.exe', source], cwd=path+'/src', shell=True)
            if rc.returncode!=0:
                raise FileNotFoundError
            VS_compile_succeed=True
        except:
            print('Visual Studio compile failed, trying GCC!')
    
    if not VS_compile_succeed:
        try:
            rc = subprocess.run([compiler,source,'-o','my_code.exe'], cwd=path+'/src', shell=True)
            if rc.returncode!=0:
                raise FileNotFoundError
        except:
            print('!!Compile dropped to fallback!!')
            rc = subprocess.run([compiler+' '+source+' -o my_code.exe'], cwd=path+'/src', shell=True)
            print("Fallback completed, don't worry")


    try:
        cmd_line=['./my_code.exe']+cmdline_args
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
        if rc.returncode!=0:
            raise FileNotFoundError
    except:
        print('!!Running dropped to fallback!!')
        cmd_line=[path+'\\src\\my_code.exe']+cmdline_args
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
        print("Fallback completed, don't worry")

    return rc.stdout

def callCPPFunction(cmdline_args=[], input='', timeout=30, compiler='g++', source='my_code.cpp', testmain='../tests/testmain.cpp', enable_VS=True):
    """
    Execute a C++ program and return the output.

    This function compiles and executes a C++ program located in the `src` directory of the current project. It delegates the compilation and execution to the appropriate compiler (g++ by default) or the Visual Studio compiler if enabled.

    Args:
        cmdline_args (list, optional): Additional command-line arguments to pass to the program. Defaults to [].
        input (str, optional): Input to be passed to the program. Defaults to ''.
        timeout (int, optional): Maximum time in seconds to wait for the program to execute. Defaults to 30.
        compiler (str, optional): Compiler to use for compilation. Defaults to 'g++'.
        source (str, optional): Name of the C++ source file. Defaults to 'my_code.cpp'.
        testmain (str, optional): Path to the test main file used for compilation. Defaults to '../tests/testmain.cpp'.
        enable_VS (bool, optional): Flag indicating whether to enable Visual Studio compiler. Defaults to True.

    Returns:
        str: Standard output generated by the executed program.

    Notes:
        - If Visual Studio compiler is enabled (`enable_VS=True`), the function attempts to compile the source code using `cl.exe`.
        - If compilation fails or Visual Studio compiler is not enabled, the function falls back to the specified compiler (g++ by default) to compile the source code.
        - The compiled program is executed, and its standard output is returned.
    """
    return callCFunction(cmdline_args, input, timeout, compiler, source, testmain, enable_VS)


def callCFunction(cmdline_args=[], input='', timeout=30, compiler='gcc', source='my_code.c', testmain='../tests/testmain.c', enable_VS=True):
    """
    Execute a C program and return the output.

    This function compiles and executes a C program located in the `src` directory of the current project. It delegates the compilation and execution to the appropriate compiler (gcc by default) or the Visual Studio compiler if enabled.

    Args:
        cmdline_args (list, optional): Additional command-line arguments to pass to the program. Defaults to [].
        input (str, optional): Input to be passed to the program. Defaults to ''.
        timeout (int, optional): Maximum time in seconds to wait for the program to execute. Defaults to 30.
        compiler (str, optional): Compiler to use for compilation. Defaults to 'gcc'.
        source (str, optional): Name of the C source file. Defaults to 'my_code.c'.
        testmain (str, optional): Path to the test main file used for compilation. Defaults to '../tests/testmain.c'.
        enable_VS (bool, optional): Flag indicating whether to enable Visual Studio compiler. Defaults to True.

    Returns:
        str: Standard output generated by the executed program.

    Notes:
        - If Visual Studio compiler is enabled (`enable_VS=True`), the function attempts to compile the source code using `cl.exe`.
        - If compilation fails or Visual Studio compiler is not enabled, the function falls back to the specified compiler (gcc by default) to compile the source code.
        - The compiled program is executed, and its standard output is returned.
    """
    path=getpath()

    #Compile the source code
    VS_compile_succeed=False
    if enable_VS:
        try:
            rc = subprocess.run(['cl.exe', source, testmain, '/DCLIBRARYTEST'], cwd=path+'/src', shell=True)
            if rc.returncode!=0:
                raise FileNotFoundError
            VS_compile_succeed=True
        except:
            print('Visual Studio compile failed, trying GCC!')
    
    if not VS_compile_succeed:
        try:
            rc = subprocess.run([compiler, source, testmain, '-o', 'my_code.exe', '-D', 'CLIBRARYTEST'], cwd=path+'/src', shell=True)
            if rc.returncode!=0:
                raise FileNotFoundError
        except:
            print('!!Compile dropped to fallback!!')
            rc = subprocess.run([compiler+' '+source+' '+testmain+' -o my_code.exe -DCLIBRARYTEST'], cwd=path+'/src', shell=True)
            print("Fallback completed, don't worry")


    try:
        cmd_line=['./my_code.exe']+cmdline_args
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
        if rc.returncode!=0:
            raise FileNotFoundError
    except:
        print('!!Running dropped to fallback!!')
        cmd_line=[path+'\\src\\my_code.exe']+cmdline_args
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
        print("Fallback completed, don't worry")

    return rc.stdout

def split(s):
    """
    Split a string based on forward slashes or backslashes.

    This function splits the input string `s` using regular expression pattern matching. 
    It identifies forward slashes (/) and backslashes (\\) as delimiters and splits the string accordingly.

    Args:
        s (str): Input string to be split.

    Returns:
        list: List of substrings obtained by splitting the input string.

    Example:
        >>> split("path/to/file\\name")
        ['path', 'to', 'file', 'name']
    """
    return re.split('/|\\\\', s)

def runTest():
    """
    Run the unit tests defined in a module.

    This function executes the unit tests defined in the specified module. 
    It prints the name of the current directory, loads the test module, 
    creates a test suite using the unittest module's TestLoader, 
    runs the test suite using a TextTestRunner with verbosity set to 2, 
    and writes the test results to a file named 'result.txt'.

    Example:
        >>> runTest()
        Test test_directory_name
        result.testsRun tests completed successfully
    """

    #Get the path to the test directory
    current_dir = os.getcwd()
    testpath = os.path.join(current_dir, 'tests')

    #Remove the result file
    resultfile=os.path.join(testpath, 'result.txt')
    try:
        os.remove(resultfile)
    except:
        pass

    sys.path.insert(0, testpath)
    sys.path.insert(0, os.path.join(current_dir,'src'))

    test_file = os.path.join(testpath, 'tests.py')

    #Run the tests
    suite = unittest.TestSuite()
    if os.path.exists(test_file):
        loader = unittest.TestLoader()
        suite.addTest(loader.discover(start_dir=testpath, pattern='tests.py'))
    else:
        print('No test file found!')
        return
    
    print('Test', os.path.basename(current_dir))

    result = unittest.TextTestRunner(verbosity=2).run(suite)

    #Write the result file
    outputfile=open(resultfile, 'wt')
    outputfile.write('{0}\t{1}'.format(result.testsRun, result.testsRun - len(result.failures)))
    outputfile.close()  
    if result.errors or result.failures:
        failed_tests = len(result.errors) + len(result.failures)
        print(f"{failed_tests}/{result.testsRun} tests failed!!")
    else:
        print(f"{result.testsRun} tests completed successfully!")