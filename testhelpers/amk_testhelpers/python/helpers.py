  # -*- coding: utf-8 -*-
"""
Module for handling various utility functions and executing code for testing purposes.

This module provides functions for running Python code snippets for testing purposes.
It includes functions for executing code, and interacting with subprocesses.

Functions:
    - checkStudentImports(): Check the import statements in the student's code.
    - checkAllowedLibraries(): Check student imports against the list of allowed libraries and print any missing ones.
    - checkDeniedLibraries(): Check student imports against the list of denied libraries and raise an exception if any are found.
    - callpythoncode(): Executes Python code snippets.
    - callpythonmaincode(): Executes Python code snippets along with the main code.
    - loadmycode(): Loads the student's Python code.
    - callpython(): Executes the main Python code.
    - callpython_subprocess(): Runs the main Python code in a separate thread.
    - load_python_code(): Loads the Python code from the source file.
"""
import sys
import subprocess
import os
import threading

def checkStudentImports():
    """
    Check the import statements in the student's code.

    if path exists, open the file and read the lines.
    if the file is not found, print a message and return an empty list.

    return: List of import statements in the student's code.
    """
    path = os.getcwd() + '/src/my_code.py'

    if os.path.exists(path):
        with open (path, 'r') as f:
            lines = f.readlines()
    else:
        print('File not found:', path)
        return []
    
    imports = [line.strip() for line in lines if line.startswith('import') or line.startswith('from')]
    return imports

def checkAllowedLibraries():
    """
    Check student imports against the list of allowed libraries and print any missing ones.

    This function checks the libraries imported by the student against the list of allowed libraries
    specified in the 'allowed_libraries.txt' file. If any imported libraries are not found in the
    allowed list, they are printed as missing.

    Returns:
        None
    """
    
    studentlibs = checkStudentImports()
    
    script_directory = os.path.dirname(os.path.abspath(__file__))
    file_path = os.path.join(script_directory, 'allowed_libraries.txt')

    if os.path.exists(file_path):
        with open(file_path, 'r') as f:
            lines = f.readlines()
    else:
        print(f"File {file_path} does not exist")

    lines = [line.strip() for line in lines]
    
    missinglibs = [name for name in studentlibs if not any(item in name for item in lines)]
    if missinglibs:
        print('Tearher has not allowed the following libraries:')
        print(f"Missing library: {missinglibs}")


def checkDeniedLibraries(denied_libraries):
    """
    This function checks the libraries imported by the student against the list of denied libraries.

    Specified in the 'denied_libraries' parameter. If any imported libraries are found in the denied list,
    an exception is raised.
    """
    studentlibs = checkStudentImports()

    deniedlibs = [name for name in studentlibs if any(item in name for item in denied_libraries)]
    if deniedlibs:
        raise Exception('You are not allowed to use the following libraries on this task: ' + str(deniedlibs))


def callpythoncode(code, cmdline_args=[], input='', timeout=30):
    """
    Execute the provided Python code in a separate process.

    Args:
        code (str): Python code to execute.
        cmdline_args (list, optional): Command-line arguments to pass to the executed code (default []). 
        input (str, optional): Input to provide to the executed code (default '').
        timeout (int, optional): Maximum time (in seconds) to allow the execution before timing out (default 30).

    Returns:
        str: Standard output generated by the executed code.

    Raises:
        TimeoutExpired: If the execution exceeds the specified timeout.

    Note:
        The provided Python code is executed in a separate process. 
        Any standard output generated by the executed code is returned as a string.
        If the execution times out, a TimeoutExpired exception is raised.

    """
    path = os.getcwd()

    testcodefile='tests/my_test_code.py'
    f=open(testcodefile, "w")
    f.write(code)
    f.close()
    
    cmd_line=[sys.executable, '../'+testcodefile,]+cmdline_args
    try:
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
    except subprocess.TimeoutExpired:
        print('Timeout expired!')
        return ''
    except:
        print('Execute dropped to fallback!')
        cmd_line_str=' '.join(cmd_line)
        rc = subprocess.run(cmd_line_str, cwd=path+'/src', stdout=subprocess.PIPE, universal_newlines=True, input=input, timeout=timeout)
        print("Fallback completed, don't worry")

    os.remove(testcodefile)    
    
    return rc.stdout

#Run my_code.py and additional code
def callpythonmaincode(code, cmdline_args=[], input='', timeout=30):
    """
        Execute the provided Python code along with the main code in a separate process.

        This function first loads the main Python code from the file specified by 'loadmycode()',
        then combines it with the provided 'code' parameter, and finally executes the combined
        code in a separate process.

        Args:
        code (str): Additional Python code to execute along with the main code.
        cmdline_args (list, optional): Command-line arguments to pass to the executed code (default []). 
        input (str, optional): Input to provide to the executed code (default '').
        timeout (int, optional): Maximum time (in seconds) to allow the execution before timing out (default 30).

        Returns:
            str: Standard output generated by the executed code.

        Raises:
            TimeoutExpired: If the execution exceeds the specified timeout.

        Note:
            The provided 'code' parameter is combined with the main Python code obtained
            using the 'loadmycode()' function. The combined code is then executed in a 
            separate process. Any standard output generated by the executed code is 
            returned as a string. If the execution times out, a TimeoutExpired exception 
            is raised.

    """
    my_code=loadmycode()

    return callpythoncode(code=my_code+code, cmdline_args=cmdline_args, input=input, timeout=timeout)

#Load student code
def loadmycode(codefile='src/my_code.py'):
    """
    Load the Python code from the specified file.

    This function attempts to read the Python code from the file specified by the 'codefile'
    parameter. It tries different encodings ('latin1', 'utf8', 'utf16', 'cp437') to decode
    the file content until successful or until all encodings have been attempted.

    Args:
        codefile (str, optional): Path to the Python code file to load (default 'src/my_code.py').

    Returns:
        str: Loaded Python code as a string.

    """
    for encoding in ['latin1', 'utf8','utf16','cp437']:
        try:
            with open(codefile, encoding=encoding) as f:
                my_code = f.read()
            return my_code
        except:
            pass

#Run my_code.py
def callpython(cmdline_args=[], input='', timeout=30, denied_libs=[]):
    """
    Run a Python script with optional command-line arguments, input, and timeout.

    This function executes a Python script specified by the 'my_code.py' file in the 'src' directory.
    It allows passing optional command-line arguments and input to the script, and sets a timeout
    for the execution.

    Args:
        cmdline_args (list, optional): List of command-line arguments to pass to the Python script (default []).
        input (str, optional): Input string to provide to the Python script (default '').
        timeout (int, optional): Timeout value in seconds for the script execution (default 30).

    Returns:
        str: Output generated by the Python script.

    Raises:
        subprocess.TimeoutExpired: If the execution of the Python script exceeds the specified timeout.
        FileNotFoundError: If the Python interpreter is not found or if the 'my_code.py' file does not exist.

    Note:
        This function executes the Python script using the 'subprocess' module. It captures the standard output
        of the script and returns it as a string. If the execution exceeds the specified timeout, a 
        subprocess.TimeoutExpired exception is raised.

    """
    path = os.getcwd()
    checkAllowedLibraries()
    if denied_libs:
        checkDeniedLibraries(denied_libs)

    cmd_line=[sys.executable, 'my_code.py',]+cmdline_args
    try:
        rc = subprocess.run(cmd_line, cwd=path+'/src', stdout=subprocess.PIPE, text=True, input=input, timeout=timeout)
    except subprocess.TimeoutExpired:
        print('Timeout expired!')
        return ''
    except:
        print('Execute dropped to fallback!')
        cmd_line_str=' '.join(cmd_line)
        print('"',cmd_line_str, '"')
        rc = subprocess.run(cmd_line_str, cwd=path+'/src', stdout=subprocess.PIPE, universal_newlines=True, input=input, timeout=timeout)
        print("Fallback completed, don't worry")

    return rc.stdout



#Run my_code.py in separate thread
def callpython_subprocess(cmdline_args=[], input='', timeout=30):
    """
    Run a Python script in a separate thread with optional command-line arguments, input, and timeout.

    This function creates a new thread to execute a Python script specified by the 'my_code.py' file 
    in the 'src' directory. It allows passing optional command-line arguments and input to the script, 
    and sets a timeout for the execution.

    Args:
        cmdline_args (list, optional): List of command-line arguments to pass to the Python script (default []).
        input (str, optional): Input string to provide to the Python script (default '').
        timeout (int, optional): Timeout value in seconds for the script execution (default 30).

    Returns:
        threading.Thread: A Thread object representing the newly created thread.

    Note:
        This function creates a new thread using the 'threading' module to execute the Python script 
        asynchronously. It does not wait for the script to complete and returns the Thread object 
        immediately. The execution of the script happens concurrently in the background. Use the 
        'join' method of the returned Thread object to wait for the script execution to finish if needed.
        Any exceptions that occur during the script execution will not be raised immediately in the 
        main thread but can be handled by checking the status of the Thread object.

    """
    th=threading.Thread(target=callpython, args=(cmdline_args, input, timeout))
    th.start()
    return th

def load_python_code():
    """
    Load the contents of the Python script 'my_code.py' located in the 'src' directory.

    This function reads the contents of the Python script 'my_code.py' and returns it as a string.

    Returns:
        str: Contents of the Python script 'my_code.py'.
    """
    file_name=os.getcwd()+'/src/my_code.py'
    with open(file_name) as f:
        contents = f.read()
        return contents